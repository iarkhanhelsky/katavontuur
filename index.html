<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Platformer Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
        }
        #game-container {
            border: 2px solid #34495e;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        #wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        #debug-controls {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }
        #debug-controls label {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        #debug-controls input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        /* Reload Button */
        #reload-button {
            background-color: rgba(231, 76, 60, 0.8);
            border: 2px solid rgba(231, 76, 60, 1);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            user-select: none;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        #reload-button:hover {
            background-color: rgba(231, 76, 60, 1);
        }
        
        #reload-button:active {
            transform: scale(0.95);
        }
        
        /* Mobile Joystick Controls */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            z-index: 1000;
            pointer-events: none;
            display: block; /* Always visible */
        }
        
        /* Joystick Container */
        #joystick-container {
            position: absolute;
            left: 30px;
            bottom: 30px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        #joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease-out;
        }
        
        /* Jump Button */
        #jump-button {
            position: absolute;
            right: 30px;
            bottom: 30px;
            width: 100px;
            height: 100px;
            background: rgba(76, 175, 80, 0.7);
            border: 3px solid rgba(76, 175, 80, 0.9);
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #jump-button:active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.95);
        }
        
    </style>
</head>
<body>
    <div id="wrapper">
        <div id="debug-controls">
            <label>
                <input type="checkbox" id="debug-checkbox">
                Show Hit Boxes (Debug)
            </label>
        </div>
        <div id="game-container">
            <div id="mobile-controls">
                <div id="joystick-container">
                    <div id="joystick-base"></div>
                    <div id="joystick-stick"></div>
                </div>
                <div id="jump-button">JUMP</div>
            </div>
        </div>
        <button id="reload-button">Reload Level</button>
    </div>

    <!-- Phaser.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

    <!-- Tile System Scripts -->
    <script src="tile-analyzer.js"></script>
    <script src="tile-config.js"></script>
    <script src="tile-rules.js"></script>

    <script>
        // Global variables
        let cat;
        let cursors;
        let wasd;
        let lastInputTime = 0;
        const IDLE_DELAY = 150; // milliseconds
        let platforms;
        let decorativeObjects;
        let coins;
        let score = 0;
        let scoreText;
        let currentAnimation = '';
        let firstUpdate = true;
        let gameScene = null; // Store reference to the scene for reloading
        
        // Debug variables
        let debugMode = false;
        
        // Mobile joystick variables
        let joystickActive = false;
        let joystickX = 0;
        let joystickY = 0;
        let joystickBaseX = 0;
        let joystickBaseY = 0;
        let joystickRadius = 0;
        let jumpButtonPressed = false;
        let activeTouchId = null;
        
        // Infinite world generation variables
        let lastGeneratedX = 0;
        const GENERATION_DISTANCE = 400; // Generate platforms this far ahead
        const CLEANUP_DISTANCE = 600; // Remove platforms this far behind
        const MAX_WORLD_WIDTH = 100000; // Very large world bounds
        
        // Tile adjacency system
        let tileAnalyzer;
        let tileConfig;
        let tileRules;
        let tileGrid = new Map(); // Track placed tiles: key = "x,y" -> { tileKey, sprite }
        let allTileKeys = []; // All available tile keys
        let compatibilityMatrixLoaded = false;
        
        // Cat animation configuration - switch between 'cat' and 'cat2'
        const CAT_TYPE = 'cat2'; // Change this to 'cat' or 'cat2' to switch animations
        
        // Cat animation configurations
        const CAT_CONFIGS = {
            'cat': {
                frameWidth: 32,
                frameHeight: 32,
                scale: 3.6,
                animations: {
                    idle: { frames: 8, frameRate: 10, path: 'Idle-Stand-01-Sheet.png' },
                    walk: { frames: 32, frameRate: 12, path: 'Walk-01-HeadHigh-Sheet.png' },
                    jump: { frames: 5, frameRate: 10, path: 'Jump-01-Sheet.png' }
                }
            },
            'cat2': {
                frameWidth: 64,
                frameHeight: 64,
                scale: 2.0,
                animations: {
                    idle: { frames: 7, frameRate: 10, path: 'idle.png' },
                    walk: { frames: 7, frameRate: 12, path: 'walk.png' },
                    jump: { frames: 7, frameRate: 10, path: 'jump.png' },
                    run: { frames: 7, frameRate: 12, path: 'run.png' }
                }
            }
        };
        
        // Store bounding boxes for each animation
        let animationBoundingBoxes = {};
        
        // World dimensions
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        // Scale background to fit canvas height (600px)
        const BG_SCALE = CANVAS_HEIGHT / 1143; // Scale factor to fit height
        const WORLD_WIDTH = 2000 * BG_SCALE; // Scaled world width
        const WORLD_HEIGHT = CANVAS_HEIGHT; // World height matches canvas
        const TILE_SIZE = 128 * BG_SCALE; // Scale tiles to match world

        // Calculate bounding box for a sprite frame (detects actual content, not transparent pixels)
        function calculateBoundingBox(scene, textureKey, frameIndex = 0) {
            try {
                const texture = scene.textures.get(textureKey);
                if (!texture) {
                    console.warn(`Texture ${textureKey} not found for bounding box calculation`);
                    return null;
                }
                
                const frame = texture.get(frameIndex);
                if (!frame) {
                    console.warn(`Frame ${frameIndex} not found in texture ${textureKey}`);
                    return null;
                }
                
                // Get the source image
                const source = texture.source[0];
                if (!source || !source.image) {
                    console.warn(`Source image not available for texture ${textureKey}`);
                    // Fallback: return full frame size
                    return {
                        x: 0,
                        y: 0,
                        width: frame.width,
                        height: frame.height
                    };
                }
                
                // Create a temporary canvas to analyze the specific frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frame.width;
                tempCanvas.height = frame.height;
                const ctx = tempCanvas.getContext('2d');
                
                // Draw the frame to temp canvas
                // Frame coordinates in the source image
                const sx = frame.cutX;
                const sy = frame.cutY;
                const sw = frame.cutWidth;
                const sh = frame.cutHeight;
                
                ctx.drawImage(
                    source.image,
                    sx, sy, sw, sh,
                    0, 0, frame.width, frame.height
                );
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, frame.width, frame.height);
                const data = imageData.data;
                
                // Find bounding box (non-transparent pixels)
                let minX = frame.width;
                let minY = frame.height;
                let maxX = 0;
                let maxY = 0;
                let foundPixel = false;
                
                for (let y = 0; y < frame.height; y++) {
                    for (let x = 0; x < frame.width; x++) {
                        const idx = (y * frame.width + x) * 4;
                        const alpha = data[idx + 3];
                        if (alpha > 0) { // Non-transparent pixel
                            foundPixel = true;
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                // If no content found, return full frame size
                if (!foundPixel || minX > maxX || minY > maxY) {
                    return {
                        x: 0,
                        y: 0,
                        width: frame.width,
                        height: frame.height
                    };
                }
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX + 1,
                    height: maxY - minY + 1
                };
            } catch (error) {
                console.error(`Error calculating bounding box for ${textureKey}:`, error);
                // Fallback: return full frame size
                const texture = scene.textures.get(textureKey);
                if (texture) {
                    const frame = texture.get(frameIndex);
                    if (frame) {
                        return {
                            x: 0,
                            y: 0,
                            width: frame.width,
                            height: frame.height
                        };
                    }
                }
                return null;
            }
        }
        
        // Calculate bounding boxes for all frames in an animation
        function calculateAnimationBoundingBoxes(scene, textureKey, frameCount) {
            const boxes = [];
            for (let i = 0; i < frameCount; i++) {
                const box = calculateBoundingBox(scene, textureKey, i);
                if (box) {
                    boxes.push(box);
                }
            }
            
            // Find the union of all bounding boxes (largest box that contains all frames)
            if (boxes.length === 0) return null;
            
            let unionMinX = Math.min(...boxes.map(b => b.x));
            let unionMinY = Math.min(...boxes.map(b => b.y));
            let unionMaxX = Math.max(...boxes.map(b => b.x + b.width));
            let unionMaxY = Math.max(...boxes.map(b => b.y + b.height));
            
            return {
                x: unionMinX,
                y: unionMinY,
                width: unionMaxX - unionMinX,
                height: unionMaxY - unionMinY
            };
        }
        
        // Update cat body size based on current animation
        function updateCatBodySize(scene, animationKey) {
            if (!cat || !cat.body) return;
            
            const config = CAT_CONFIGS[CAT_TYPE];
            const scale = config.scale;
            const frameWidth = config.frameWidth * scale;
            const frameHeight = config.frameHeight * scale;
            
            // Get bounding box for this animation
            const boundingBox = animationBoundingBoxes[animationKey];
            if (!boundingBox) {
                // Fallback to frame size if bounding box not calculated
                cat.body.setSize(frameWidth, frameHeight);
                cat.body.setOffset(0, 0);
                cat.body.refreshBody();
                return;
            }
            
            // Use bounding box for width (to prevent horizontal floating)
            // But ensure body always extends to bottom of frame for ground collision
            const bodyWidth = Math.max(boundingBox.width * scale, frameWidth * 0.6);
            // Body height should always extend to bottom of frame
            const bodyHeight = frameHeight;
            
            // Calculate offset: use bounding box X offset, but Y should be 0 so body starts at top
            const offsetX = boundingBox.x * scale;
            const offsetY = 0; // Always start at top of frame
            
            cat.body.setSize(bodyWidth, bodyHeight);
            cat.body.setOffset(offsetX, offsetY);
            cat.body.refreshBody(); // Critical: refresh body to apply changes
        }
        
        // Load cat animations based on CAT_TYPE
        function loadCatAnimations(scene) {
            const config = CAT_CONFIGS[CAT_TYPE];
            const basePath = `assets/animations/${CAT_TYPE}/`;
            
            // Load all animation sprite sheets
            for (const [animKey, animConfig] of Object.entries(config.animations)) {
                const textureKey = `cat-${animKey}`;
                scene.load.spritesheet(textureKey, basePath + animConfig.path, {
                    frameWidth: config.frameWidth,
                    frameHeight: config.frameHeight
                });
            }
        }
        
        // Create cat animations based on CAT_TYPE
        function createCatAnimations(scene) {
            const config = CAT_CONFIGS[CAT_TYPE];
            animationBoundingBoxes = {};
            
            // Helper function to check if textures are ready
            const checkAndCreateAnimations = () => {
                let allTexturesReady = true;
                for (const [animKey, animConfig] of Object.entries(config.animations)) {
                    const textureKey = `cat-${animKey}`;
                    const texture = scene.textures.get(textureKey);
                    if (!texture || !texture.source || !texture.source[0] || !texture.source[0].image) {
                        allTexturesReady = false;
                        break;
                    }
                }
                
                if (!allTexturesReady) {
                    // Retry after a short delay
                    scene.time.delayedCall(100, checkAndCreateAnimations);
                    return;
                }
                
                // All textures are ready, create animations and calculate bounding boxes
                for (const [animKey, animConfig] of Object.entries(config.animations)) {
                    const textureKey = `cat-${animKey}`;
                    const texture = scene.textures.get(textureKey);
                    
                    if (!texture) {
                        console.warn(`Texture ${textureKey} not found`);
                        continue;
                    }
                    
                    // Create animation first
                    if (texture.frameTotal >= animConfig.frames) {
                        scene.anims.create({
                            key: animKey,
                            frames: scene.anims.generateFrameNumbers(textureKey, { 
                                start: 0, 
                                end: animConfig.frames - 1 
                            }),
                            frameRate: animConfig.frameRate,
                            repeat: -1 // loop forever
                        });
                    }
                    
                    // Calculate bounding boxes for this animation (may fail, that's OK)
                    try {
                        const boundingBox = calculateAnimationBoundingBoxes(scene, textureKey, animConfig.frames);
                        if (boundingBox) {
                            animationBoundingBoxes[animKey] = boundingBox;
                            console.log(`Bounding box for ${animKey}:`, boundingBox);
                        }
                    } catch (error) {
                        console.warn(`Failed to calculate bounding box for ${animKey}:`, error);
                    }
                }
                
                // Update body size for initial animation
                if (cat && cat.body) {
                    updateCatBodySize(scene, 'idle');
                }
            };
            
            // Start checking after a short delay
            scene.time.delayedCall(100, checkAndCreateAnimations);
        }
        
        // Preload function - loads all assets
        function preload() {
            // Load cat animations based on CAT_TYPE
            loadCatAnimations(this);
            
            // Load coin sprite sheet
            this.load.spritesheet('coin', 'assets/animations/coin/coins.png', {
                frameWidth: 40,
                frameHeight: 40
            });
            
            // Load background image
            this.load.image('background', 'assets/world/BG.png');
            
            // Load all tile images (16 tiles)
            for (let i = 1; i <= 16; i++) {
                this.load.image(`tile-${i}`, `assets/world/Tiles/Tile (${i}).png`);
            }
            
            // Load bone tile images (4 bones)
            for (let i = 1; i <= 4; i++) {
                this.load.image(`bone-${i}`, `assets/world/Tiles/Bones (${i}).png`);
            }
            
            // Load decorative object images
            this.load.image('tree', 'assets/world/Objects/Tree.png');
            this.load.image('bush-1', 'assets/world/Objects/Bush (1).png');
            this.load.image('bush-2', 'assets/world/Objects/Bush (2).png');
            this.load.image('crate', 'assets/world/Objects/Crate.png');
            this.load.image('dead-bush', 'assets/world/Objects/DeadBush.png');
            this.load.image('arrow-sign', 'assets/world/Objects/ArrowSign.png');
            this.load.image('sign', 'assets/world/Objects/Sign.png');
            this.load.image('skeleton', 'assets/world/Objects/Skeleton.png');
            this.load.image('tombstone-1', 'assets/world/Objects/TombStone (1).png');
            this.load.image('tombstone-2', 'assets/world/Objects/TombStone (2).png');
            
            // Load tile compatibility matrix (if it exists)
            // Note: Phaser will fail silently if file doesn't exist, which is fine
            this.load.json('tile-compatibility-matrix', 'assets/tile-compatibility-matrix.json');
        }

        // Create function - sets up the game scene
        function create() {
            // Store scene reference for reloading
            gameScene = this;
            
            // Reset global state variables
            lastGeneratedX = 0;
            tileGrid.clear();
            firstUpdate = true;
            currentAnimation = '';
            joystickActive = false;
            joystickX = 0;
            joystickY = 0;
            jumpButtonPressed = false;
            activeTouchId = null;
            
            // Set up keyboard input first (before any early returns)
            cursors = this.input.keyboard.createCursorKeys();
            wasd = this.input.keyboard.addKeys('W,S,A,D,SPACE');
            
            // Initialize mobile joystick
            initializeMobileJoystick(this);
            
            // Function to toggle debug mode
            const toggleDebugMode = (enabled) => {
                debugMode = enabled;
                // Create debug graphics if needed
                if (debugMode && !this.debugGraphics) {
                    this.debugGraphics = this.add.graphics();
                }
                console.log('Debug mode:', debugMode ? 'ON' : 'OFF');
            };
            
            // Connect HTML checkbox to debug mode
            const debugCheckbox = document.getElementById('debug-checkbox');
            if (debugCheckbox) {
                debugCheckbox.addEventListener('change', (e) => {
                    toggleDebugMode(e.target.checked);
                });
            }
            
            // Initialize debug graphics (hidden initially)
            // Set scroll factor to 1 so it scrolls with the world
            this.debugGraphics = this.add.graphics();
            this.debugGraphics.setScrollFactor(1);
            this.debugGraphics.setVisible(false);
            
            // Initialize last input time
            lastInputTime = Date.now();
            
            // Display background image - scale to fit canvas height (600px)
            // Background is static (fixed to camera, not world)
            const bg = this.add.image(0, 0, 'background').setOrigin(0, 0);
            bg.setScale(BG_SCALE);
            // Make background fixed to camera (doesn't scroll)
            bg.setScrollFactor(0);
            
            // Set world bounds to be very large for infinite generation
            this.physics.world.setBounds(0, 0, MAX_WORLD_WIDTH, WORLD_HEIGHT);
            
            // Create platforms static group (must be created before cat for collision)
            platforms = this.physics.add.staticGroup();
            
            // Create decorative objects group (non-physics)
            decorativeObjects = this.add.group();
            
            // Create coins physics group
            coins = this.physics.add.group();
            
            // Initialize tile system
            initializeTileSystem(this);
            
            // Generate matrix if needed (runs in background)
            generateCompatibilityMatrixIfNeeded(this);
            
            // Initialize world generation - create initial platforms (MUST happen before cat creation)
            lastGeneratedX = 0;
            console.log('Generating initial world chunk...');
            generateWorldChunk(this, 0, CANVAS_WIDTH * 2);
            console.log(`World generation complete. Platforms created: ${platforms.children.entries.length}`);
            
            // Check if cat textures loaded successfully before creating cat
            const idleTextureKey = `cat-idle`;
            if (this.textures.exists(idleTextureKey)) {
                // Create cat sprite using idle sprite sheet as base
                // Position cat on ground level
                // Ground tile center is at WORLD_HEIGHT - TILE_SIZE/2
                // Cat's feet should be on top of the tile, so cat Y = ground tile top - half cat height
                const config = CAT_CONFIGS[CAT_TYPE];
                const groundTileCenterY = WORLD_HEIGHT - TILE_SIZE / 2;
                const groundTileTop = groundTileCenterY - TILE_SIZE / 2;
                const catHeight = config.frameHeight * config.scale; // Cat sprite height * scale
                const catStartY = groundTileTop - catHeight / 2;
                cat = this.physics.add.sprite(100, catStartY, 'cat-idle');
                
                // Scale cat based on configuration
                cat.setScale(config.scale);
                
                // Enable physics properties
                cat.setCollideWorldBounds(false); // Camera will handle bounds
                cat.setBounce(0);
                cat.body.setGravityY(300);
                
                // Set initial body size (will be updated when bounding boxes are calculated)
                cat.body.setSize(config.frameWidth * config.scale, config.frameHeight * config.scale);
                cat.body.setOffset(0, 0);
                cat.body.refreshBody(); // Refresh to apply initial body size
                
                // Set collision between cat and platforms
                this.physics.add.collider(cat, platforms);
                
                // Set up overlap detection for coin collection
                this.physics.add.overlap(cat, coins, collectCoin, null, this);
            } else {
                console.error(`Failed to load ${idleTextureKey} texture - cat will not be created`);
            }
            
            // Configure camera to follow cat (if cat was created)
            this.cameras.main.setBounds(0, 0, MAX_WORLD_WIDTH, WORLD_HEIGHT);
            if (cat) {
                this.cameras.main.startFollow(cat, true, 0.1, 0.1);
                this.cameras.main.setDeadzone(100, 100);
            }
            
            // Create score display
            score = 0;
            scoreText = this.add.text(16, 16, 'Score: 0', {
                fontSize: '32px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            scoreText.setScrollFactor(0); // Fixed to camera
            
            // Create cat animations (this will also calculate bounding boxes)
            createCatAnimations(this);
            
            // Coin animation: 4 frames (40x178 sprite sheet = 4 frames of 40x40)
            const coinTexture = this.textures.get('coin');
            if (coinTexture && coinTexture.frameTotal >= 4) {
                this.anims.create({
                    key: 'coin-spin',
                    frames: this.anims.generateFrameNumbers('coin', { start: 0, end: 3 }),
                    frameRate: 10,
                    repeat: -1 // loop forever
                });
            }
            
            // Set initial frame - don't play animation yet
            cat.setFrame(0);
            currentAnimation = '';
        }
        
        // Initialize tile adjacency system
        async function initializeTileSystem(scene) {
            // Build list of all tile keys (excluding bones - they are decorative overlays only)
            allTileKeys = [];
            for (let i = 1; i <= 16; i++) {
                allTileKeys.push(`tile-${i}`);
            }
            // Bones are not included in allTileKeys - they are decorative overlays only
            
            // Initialize tile system components
            tileAnalyzer = new TileAnalyzer(scene);
            tileConfig = new TileConfig();
            tileRules = new TileRules(tileAnalyzer, tileConfig);
            
            // Try to load pre-computed compatibility matrix
            try {
                if (scene.cache.json.exists('tile-compatibility-matrix')) {
                    const matrixData = scene.cache.json.get('tile-compatibility-matrix');
                    if (matrixData && Object.keys(matrixData).length > 0) {
                        tileRules.loadMatrix(matrixData);
                        compatibilityMatrixLoaded = true;
                        console.log('Loaded tile compatibility matrix from asset');
                    }
                }
            } catch (e) {
                console.log('Compatibility matrix not found, will generate on first use');
            }
            
            // If matrix not loaded, generate it asynchronously
            if (!compatibilityMatrixLoaded) {
                console.log('Compatibility matrix not found, will generate on first use');
            }
            
        }
        
        // Generate compatibility matrix (called if not pre-computed)
        // This runs asynchronously in the background
        async function generateCompatibilityMatrixIfNeeded(scene) {
            if (compatibilityMatrixLoaded) return;
            
            // Wait a bit for textures to be fully loaded
            await new Promise(resolve => setTimeout(resolve, 500));
            
            try {
                console.log('Generating tile compatibility matrix (this may take a moment)...');
                const matrix = await tileRules.generateCompatibilityMatrix(allTileKeys);
                compatibilityMatrixLoaded = true;
                console.log('Tile compatibility matrix generated successfully');
                
                // Log matrix for manual saving if needed
                console.log('To save this matrix, copy the output from generate-matrix.html or use the console output');
                if (debugMode) {
                    console.log('Generated compatibility matrix:');
                    console.log(tileRules.exportMatrix());
                }
            } catch (err) {
                console.error('Error generating compatibility matrix:', err);
                console.log('Falling back to random tile selection');
            }
        }
        
        // Get grid key from world coordinates
        function getGridKey(x, y) {
            const gridX = Math.floor(x / TILE_SIZE);
            const gridY = Math.floor(y / TILE_SIZE);
            return `${gridX},${gridY}`;
        }
        
        // Get tile at grid position
        function getTileAtGrid(gridX, gridY) {
            const key = `${gridX},${gridY}`;
            return tileGrid.get(key);
        }
        
        // Get compatible tile for a position
        function getCompatibleTile(gridX, gridY, isGround = true) {
            // If matrix not ready, fall back to random
            if (!compatibilityMatrixLoaded || !tileRules) {
                return allTileKeys[Math.floor(Math.random() * allTileKeys.length)];
            }
            
            // Filter out bones - they are decorative overlays, not platform tiles
            let candidates = [...allTileKeys].filter(key => !key.startsWith('bone-'));
            
            // Check left neighbor (for horizontal adjacency)
            const leftTile = getTileAtGrid(gridX - 1, gridY);
            if (leftTile) {
                const compatible = tileRules.getCompatibleTiles(leftTile.tileKey, 'right');
                if (compatible.length > 0) {
                    candidates = candidates.filter(t => compatible.includes(t));
                }
            }
            
            // Check right neighbor (if already placed)
            const rightTile = getTileAtGrid(gridX + 1, gridY);
            if (rightTile) {
                const compatible = tileRules.getCompatibleTiles(rightTile.tileKey, 'left');
                if (compatible.length > 0) {
                    candidates = candidates.filter(t => compatible.includes(t));
                }
            }
            
            // For ground tiles, also check top/bottom if needed
            if (!isGround) {
                const topTile = getTileAtGrid(gridX, gridY - 1);
                if (topTile) {
                    const compatible = tileRules.getCompatibleTiles(topTile.tileKey, 'bottom');
                    if (compatible.length > 0) {
                        candidates = candidates.filter(t => compatible.includes(t));
                    }
                }
                
                const bottomTile = getTileAtGrid(gridX, gridY + 1);
                if (bottomTile) {
                    const compatible = tileRules.getCompatibleTiles(bottomTile.tileKey, 'top');
                    if (compatible.length > 0) {
                        candidates = candidates.filter(t => compatible.includes(t));
                    }
                }
            }
            
            // If no candidates after filtering, use all tiles except bones (fallback)
            if (candidates.length === 0) {
                candidates = allTileKeys.filter(key => !key.startsWith('bone-'));
            }
            
            // Return random compatible tile
            return candidates[Math.floor(Math.random() * candidates.length)];
        }
        
        // Coin collection handler
        function collectCoin(cat, coin) {
            // Increment score
            score++;
            // Update score display
            if (scoreText) {
                scoreText.setText('Score: ' + score);
            }
            // Remove coin
            coin.destroy();
        }
        
        // Generate a chunk of the world
        function generateWorldChunk(scene, startX, endX) {
            const groundY = WORLD_HEIGHT - TILE_SIZE / 2; // Center Y for ground tiles
            const groundTop = WORLD_HEIGHT - TILE_SIZE; // Top of ground platform
            
            // Generate ground tiles with adjacency rules
            for (let x = startX; x < endX; x += TILE_SIZE) {
                const gridX = Math.floor(x / TILE_SIZE);
                const gridY = Math.floor(groundY / TILE_SIZE);
                
                // Get compatible tile based on adjacent tiles
                const tileKey = getCompatibleTile(gridX, gridY, true);
                
                const tile = platforms.create(x + TILE_SIZE / 2, groundY, tileKey);
                tile.setScale(BG_SCALE);
                tile.setSize(TILE_SIZE / BG_SCALE, TILE_SIZE / BG_SCALE);
                tile.refreshBody();
                
                // Track tile in grid
                const gridKey = getGridKey(x + TILE_SIZE / 2, groundY);
                tileGrid.set(gridKey, { tileKey: tileKey, sprite: tile, gridX: gridX, gridY: gridY });
                
                // Add bones on top of ground tiles with 25% probability
                if (Math.random() < 0.25) {
                    const boneIndex = Math.floor(Math.random() * 4) + 1; // Random bone 1-4
                    const boneKey = `bone-${boneIndex}`;
                    const boneY = groundTop; // Position at top of ground tile
                    const bone = scene.add.image(x + TILE_SIZE / 2, boneY, boneKey);
                    bone.setScale(BG_SCALE);
                    bone.setScrollFactor(1); // Scroll with world
                    decorativeObjects.add(bone);
                }
                
                // Add coins above ground tiles with 15% probability
                if (Math.random() < 0.15) {
                    const coinY = groundTop - 50; // Position above ground
                    const coin = coins.create(x + TILE_SIZE / 2, coinY, 'coin');
                    coin.setScale(BG_SCALE);
                    coin.setScrollFactor(1); // Scroll with world
                    // Set coin body size (smaller than sprite for easier collection)
                    coin.body.setSize(30 * BG_SCALE, 30 * BG_SCALE);
                    // Make coin immovable and disable gravity so it doesn't fall
                    coin.body.setImmovable(true);
                    coin.body.setAllowGravity(false);
                    // Play coin animation
                    if (scene.anims.exists('coin-spin')) {
                        coin.anims.play('coin-spin', true);
                    }
                }
            }
            
            // Generate floating platforms (procedurally)
            // Generate platforms every 200-400 pixels
            for (let x = startX; x < endX; x += Math.random() * 200 + 200) {
                // 30% chance to generate a platform at this position
                if (Math.random() < 0.3) {
                    const platformWidth = Math.floor(Math.random() * 3) + 2; // 2-4 tiles wide
                    const platformHeight = Math.random() * 200 + 100; // 100-300px above ground
                    
                    for (let i = 0; i < platformWidth; i++) {
                        const tileX = x + (i * TILE_SIZE) + TILE_SIZE / 2;
                        const tileY = (groundTop - platformHeight) + TILE_SIZE / 2;
                        const gridX = Math.floor(tileX / TILE_SIZE);
                        const gridY = Math.floor(tileY / TILE_SIZE);
                        
                        // Get compatible tile based on adjacent tiles (horizontal only for platforms)
                        const tileKey = getCompatibleTile(gridX, gridY, false);
                        
                        const tile = platforms.create(tileX, tileY, tileKey);
                        tile.setScale(BG_SCALE);
                        tile.setSize(TILE_SIZE / BG_SCALE, TILE_SIZE / BG_SCALE);
                        tile.refreshBody();
                        
                        // Track tile in grid
                        const gridKey = getGridKey(tileX, tileY);
                        tileGrid.set(gridKey, { tileKey: tileKey, sprite: tile, gridX: gridX, gridY: gridY });
                    }
                    
                    // Occasionally add decorative objects on platforms
                    if (Math.random() < 0.2) {
                        const objX = x + (platformWidth * TILE_SIZE / 2);
                        const objY = groundTop - platformHeight;
                        const objType = Math.random() < 0.5 ? 'crate' : 'sign';
                        const obj = scene.add.image(objX, objY, objType);
                        obj.setScale(BG_SCALE);
                        obj.setScrollFactor(1); // Scroll with world
                        decorativeObjects.add(obj);
                    }
                    
                    // Add coins on platforms with 20% probability
                    if (Math.random() < 0.2) {
                        const coinX = x + (platformWidth * TILE_SIZE / 2);
                        const coinY = (groundTop - platformHeight) - 50; // Position above platform
                        const coin = coins.create(coinX, coinY, 'coin');
                        coin.setScale(BG_SCALE);
                        coin.setScrollFactor(1); // Scroll with world
                        // Set coin body size (smaller than sprite for easier collection)
                        coin.body.setSize(30 * BG_SCALE, 30 * BG_SCALE);
                        // Make coin immovable and disable gravity so it doesn't fall
                        coin.body.setImmovable(true);
                        coin.body.setAllowGravity(false);
                        // Play coin animation
                        if (scene.anims.exists('coin-spin')) {
                            coin.anims.play('coin-spin', true);
                        }
                    }
                }
            }
            
            // Occasionally add decorative objects on ground
            for (let x = startX; x < endX; x += Math.random() * 300 + 200) {
                if (Math.random() < 0.15) {
                    const objTypes = ['bush-1', 'bush-2', 'dead-bush', 'tombstone-1', 'tombstone-2', 'skeleton'];
                    const objType = objTypes[Math.floor(Math.random() * objTypes.length)];
                    const obj = scene.add.image(x, groundTop - (objType === 'tree' ? 120 : 40), objType);
                    obj.setScale(BG_SCALE);
                    obj.setScrollFactor(1); // Scroll with world
                    decorativeObjects.add(obj);
                }
            }
        }
        
        // Initialize mobile joystick
        function initializeMobileJoystick(scene) {
            // Get joystick elements
            const joystickContainer = document.getElementById('joystick-container');
            const joystickStick = document.getElementById('joystick-stick');
            const jumpButton = document.getElementById('jump-button');
            
            if (!joystickContainer || !joystickStick) {
                return;
            }
            
            // Calculate joystick base position and radius
            // We'll recalculate on each touch to handle window resizing
            const getJoystickBounds = () => {
                const rect = joystickContainer.getBoundingClientRect();
                return {
                    centerX: rect.left + rect.width / 2,
                    centerY: rect.top + rect.height / 2,
                    radius: rect.width / 2 - 30 // Leave some margin for stick movement
                };
            };
            
            // Initialize joystick bounds
            const initialBounds = getJoystickBounds();
            joystickBaseX = initialBounds.centerX;
            joystickBaseY = initialBounds.centerY;
            joystickRadius = initialBounds.radius;
            
            // Joystick touch handlers
            const handleJoystickStart = (e) => {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                activeTouchId = touch.identifier !== undefined ? touch.identifier : 0;
                joystickActive = true;
                updateJoystickPosition(touch);
            };
            
            const handleJoystickMove = (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                const touch = e.touches ? Array.from(e.touches).find(t => t.identifier === activeTouchId) : e;
                if (touch) {
                    updateJoystickPosition(touch);
                }
            };
            
            const handleJoystickEnd = (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                joystickActive = false;
                joystickX = 0;
                joystickY = 0;
                resetJoystickPosition();
            };
            
            const updateJoystickPosition = (touch) => {
                const bounds = getJoystickBounds();
                const clientX = touch.clientX;
                const clientY = touch.clientY;
                
                // Calculate distance from center
                const deltaX = clientX - bounds.centerX;
                const deltaY = clientY - bounds.centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Clamp to joystick radius
                if (distance > bounds.radius) {
                    const angle = Math.atan2(deltaY, deltaX);
                    joystickX = Math.cos(angle) * bounds.radius;
                    joystickY = Math.sin(angle) * bounds.radius;
                } else {
                    joystickX = deltaX;
                    joystickY = deltaY;
                }
                
                // Store radius for normalization in update loop
                joystickRadius = bounds.radius;
                
                // Update stick visual position
                joystickStick.style.transform = `translate(calc(-50% + ${joystickX}px), calc(-50% + ${joystickY}px))`;
            };
            
            const resetJoystickPosition = () => {
                joystickStick.style.transform = 'translate(-50%, -50%)';
            };
            
            // Add event listeners
            joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
            joystickContainer.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
            
            // Mouse support for testing on desktop (when simulating mobile)
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', (e) => {
                if (joystickActive) {
                    handleJoystickMove(e);
                }
            });
            document.addEventListener('mouseup', handleJoystickEnd);
            
            // Jump button handlers
            if (jumpButton) {
                const handleJumpStart = (e) => {
                    e.preventDefault();
                    jumpButtonPressed = true;
                };
                
                const handleJumpEnd = (e) => {
                    e.preventDefault();
                    jumpButtonPressed = false;
                };
                
                jumpButton.addEventListener('touchstart', handleJumpStart, { passive: false });
                jumpButton.addEventListener('touchend', handleJumpEnd, { passive: false });
                jumpButton.addEventListener('touchcancel', handleJumpEnd, { passive: false });
                jumpButton.addEventListener('mousedown', handleJumpStart);
                jumpButton.addEventListener('mouseup', handleJumpEnd);
                jumpButton.addEventListener('mouseleave', handleJumpEnd);
            }
            
            // Prevent default touch behaviors that might interfere
            document.addEventListener('touchmove', (e) => {
                // Only prevent if touching joystick area
                if (joystickActive || jumpButtonPressed) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // Clean up old platforms and objects
        function cleanupWorld(catX) {
            const cleanupX = catX - CLEANUP_DISTANCE;
            
            // Remove platforms behind the cat
            platforms.children.entries.forEach(tile => {
                if (tile.x < cleanupX) {
                    // Remove from grid tracking
                    const gridKey = getGridKey(tile.x, tile.y);
                    tileGrid.delete(gridKey);
                    
                    platforms.remove(tile, true, true);
                }
            });
            
            // Remove decorative objects behind the cat
            decorativeObjects.children.entries.forEach(obj => {
                if (obj.x < cleanupX) {
                    decorativeObjects.remove(obj, true, true);
                }
            });
            
            // Remove coins behind the cat
            coins.children.entries.forEach(coin => {
                if (coin.x < cleanupX) {
                    coins.remove(coin, true, true);
                }
            });
        }
        

        // Update function - handles game loop
        function update() {
            // Ensure cursors and wasd are initialized
            if (!cursors || !wasd) {
                return;
            }
            
            // Ensure cat exists
            if (!cat) {
                return;
            }
            
            // Infinite world generation - generate ahead of cat
            const catX = cat.x;
            if (catX > lastGeneratedX - GENERATION_DISTANCE) {
                const newChunkStart = lastGeneratedX;
                const newChunkEnd = lastGeneratedX + GENERATION_DISTANCE * 2;
                generateWorldChunk(this, newChunkStart, newChunkEnd);
                lastGeneratedX = newChunkEnd;
            }
            
            // Clean up old platforms and objects behind the cat
            cleanupWorld(catX);
            
            // Update debug graphics if debug mode is enabled
            if (debugMode && this.debugGraphics) {
                this.debugGraphics.clear();
                this.debugGraphics.setVisible(true);
                
                // Draw debug graphics for all physics bodies
                // Use green color for hit boxes
                this.debugGraphics.lineStyle(2, 0x00ff00, 1);
                
                // Draw cat debug
                if (cat && cat.body) {
                    const body = cat.body;
                    this.debugGraphics.strokeRect(
                        body.x,
                        body.y,
                        body.width,
                        body.height
                    );
                }
                
                // Draw platform debug
                platforms.children.entries.forEach(tile => {
                    if (tile && tile.body) {
                        const body = tile.body;
                        this.debugGraphics.strokeRect(
                            body.x,
                            body.y,
                            body.width,
                            body.height
                        );
                    }
                });
            } else if (this.debugGraphics) {
                this.debugGraphics.clear();
                this.debugGraphics.setVisible(false);
            }
            
            // Start idle animation on first update frame
            if (firstUpdate) {
                firstUpdate = false;
                if (cat && this.anims.exists('idle')) {
                    const idleAnim = this.anims.get('idle');
                    if (idleAnim && idleAnim.frames && idleAnim.frames.length > 0) {
                        cat.anims.play('idle', true);
                        currentAnimation = 'idle';
                        // Update body size for initial animation
                        updateCatBodySize(this, 'idle');
                    }
                }
            }
            
            const currentTime = Date.now();
            let leftPressed = false;
            let rightPressed = false;
            let jumpPressed = false;
            let inputDetected = false;
            
            // Check for joystick input (mobile)
            if (joystickActive) {
                const joystickThreshold = 0.3; // Dead zone threshold
                const normalizedX = joystickX / joystickRadius;
                
                if (normalizedX < -joystickThreshold) {
                    leftPressed = true;
                    inputDetected = true;
                } else if (normalizedX > joystickThreshold) {
                    rightPressed = true;
                    inputDetected = true;
                }
            }
            
            // Check for jump button (mobile)
            if (jumpButtonPressed) {
                jumpPressed = true;
                inputDetected = true;
            }
            
            // Check for input (cursors and WASD - keyboard)
            if (cursors.left.isDown || (wasd.A && wasd.A.isDown)) {
                leftPressed = true;
                inputDetected = true;
            }
            
            if (cursors.right.isDown || (wasd.D && wasd.D.isDown)) {
                rightPressed = true;
                inputDetected = true;
            }
            
            if (cursors.up.isDown || cursors.space.isDown || (wasd.W && wasd.W.isDown) || (wasd.SPACE && wasd.SPACE.isDown)) {
                jumpPressed = true;
                inputDetected = true;
            }
            
            // Update last input time if any input detected
            if (inputDetected) {
                lastInputTime = currentTime;
            }
            
            // Movement logic
            const moveSpeed = 160;
            
            if (leftPressed) {
                cat.body.setVelocityX(-moveSpeed);
            } else if (rightPressed) {
                cat.body.setVelocityX(moveSpeed);
            } else {
                cat.body.setVelocityX(0);
            }
            
            // Jump logic - only jump if on ground
            if (jumpPressed && cat.body.touching.down) {
                cat.body.setVelocityY(-500); // Increased jump velocity for higher jumps
            }
            
            // Animation state management
            const isGrounded = cat.body.touching.down;
            const timeSinceLastInput = currentTime - lastInputTime;
            const shouldBeIdle = timeSinceLastInput > IDLE_DELAY && !leftPressed && !rightPressed;
            
            let targetAnimation = currentAnimation;
            
            // Determine target animation based on state
            if (!isGrounded) {
                // In air - play jump animation
                targetAnimation = 'jump';
            } else if (leftPressed || rightPressed) {
                // Moving - play walk animation
                targetAnimation = 'walk';
            } else if (shouldBeIdle) {
                // No input for delay period - play idle
                targetAnimation = 'idle';
            }
            
            // Switch animation if different from current
            if (targetAnimation !== currentAnimation && this.anims.exists(targetAnimation)) {
                const anim = this.anims.get(targetAnimation);
                if (anim && anim.frames && anim.frames.length > 0) {
                    try {
                        cat.anims.play(targetAnimation, true);
                        currentAnimation = targetAnimation;
                        // Update body size based on new animation's bounding box
                        updateCatBodySize(this, targetAnimation);
                    } catch (error) {
                        console.error('Error playing animation:', targetAnimation, error);
                    }
                }
            }
            
            // Sprite flipping based on movement direction
            if (leftPressed) {
                cat.setFlipX(true);
            } else if (rightPressed) {
                cat.setFlipX(false);
            }
            // Note: We keep the last flip direction when idle/jumping
        }

        // Main game config
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false // Debug rendering handled manually
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Start the game
        const game = new Phaser.Game(config);
        
        // Reload level function
        function reloadLevel() {
            // Reset joystick visual position
            const joystickStick = document.getElementById('joystick-stick');
            if (joystickStick) {
                joystickStick.style.transform = 'translate(-50%, -50%)';
            }
            
            // Reset joystick state
            joystickActive = false;
            joystickX = 0;
            joystickY = 0;
            jumpButtonPressed = false;
            
            // Reset score
            score = 0;
            if (scoreText) {
                scoreText.setText('Score: 0');
            }
            
            // Restart the scene
            if (gameScene) {
                gameScene.scene.restart();
            }
        }
        
        // Connect reload button
        const reloadButton = document.getElementById('reload-button');
        if (reloadButton) {
            reloadButton.addEventListener('click', reloadLevel);
            // Also support touch events for mobile
            reloadButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                reloadLevel();
            });
        }
    </script>
</body>
</html>
