<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile Matcher - Manual Compatibility Tool</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            color: #bdc3c7;
            margin-bottom: 20px;
        }
        #game-container {
            border: 3px solid #34495e;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            background: #34495e;
            margin-bottom: 20px;
        }
        .control-panel {
            max-width: 800px;
            width: 100%;
            background: #34495e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        .info-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #2c3e50;
            border-radius: 5px;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .info-label {
            color: #bdc3c8;
        }
        .info-value {
            font-weight: bold;
            color: #3498db;
        }
        .progress-section {
            margin-bottom: 20px;
        }
        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #2c3e50;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            flex: 1;
            min-width: 120px;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-compatible {
            background: #27ae60;
            color: white;
        }
        .btn-compatible:hover:not(:disabled) {
            background: #2ecc71;
        }
        .btn-incompatible {
            background: #e74c3c;
            color: white;
        }
        .btn-incompatible:hover:not(:disabled) {
            background: #c0392b;
        }
        .btn-neutral {
            background: #3498db;
            color: white;
        }
        .btn-neutral:hover:not(:disabled) {
            background: #2980b9;
        }
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .status.info {
            background: #3498db;
        }
        .status.success {
            background: #27ae60;
        }
        .status.error {
            background: #e74c3c;
        }
        .keyboard-hints {
            margin-top: 15px;
            padding: 10px;
            background: #2c3e50;
            border-radius: 5px;
            font-size: 12px;
            color: #bdc3c7;
        }
        .keyboard-hints strong {
            color: #3498db;
        }
        .current-status {
            padding: 10px;
            background: #2c3e50;
            border-radius: 5px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
        }
        .status-compatible {
            color: #27ae60;
            font-weight: bold;
        }
        .status-incompatible {
            color: #e74c3c;
            font-weight: bold;
        }
        .status-unmarked {
            color: #95a5a6;
        }
    </style>
</head>
<body>
    <h1>Tile Matcher - Manual Compatibility Tool</h1>
    <p class="subtitle">Review tile pairs and mark which edges are compatible</p>
    
    <div id="game-container"></div>
    
    <div class="control-panel">
        <div class="info-section">
            <div class="info-row">
                <span class="info-label">Current Pair:</span>
                <span class="info-value" id="current-pair">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Direction:</span>
                <span class="info-value" id="current-direction">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Current Status:</span>
                <span class="info-value" id="current-status"><span class="status-unmarked">Unmarked</span></span>
            </div>
        </div>
        
        <div class="progress-section">
            <div class="info-row">
                <span class="info-label">Progress:</span>
                <span class="info-value" id="progress-text">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar" style="width: 0%">0%</div>
            </div>
        </div>
        
        <div class="current-status" id="status-message" style="display: none;"></div>
        
        <div class="button-group">
            <button class="btn-compatible" id="btn-compatible">✓ Compatible (Y)</button>
            <button class="btn-incompatible" id="btn-incompatible">✗ Incompatible (N)</button>
            <button class="btn-neutral" id="btn-skip">Skip (S)</button>
        </div>
        
        <div class="button-group">
            <button class="btn-secondary" id="btn-prev">← Previous</button>
            <button class="btn-secondary" id="btn-next">Next →</button>
            <button class="btn-neutral" id="btn-load">Load Existing Matrix</button>
        </div>
        
        <div class="button-group">
            <button class="btn-neutral" id="btn-save">Save Matrix (Download)</button>
            <button class="btn-neutral" id="btn-copy">Copy to Clipboard</button>
        </div>
        
        <div class="keyboard-hints">
            <strong>Keyboard Shortcuts:</strong> 
            Y = Compatible | N = Incompatible | S = Skip | 
            ← = Previous | → = Next | Space = Next
        </div>
        
        <div id="status"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script src="tile-analyzer.js"></script>
    <script src="tile-config.js"></script>
    <script src="tile-rules.js"></script>

    <script>
        // Configuration
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const TILE_DISPLAY_SIZE = 200; // Size for displaying tiles
        const TILE_SPACING = 50; // Space between tiles
        
        // State management
        let allTileKeys = [];
        let currentTile1Index = 0;
        let currentTile2Index = 0;
        let currentDirectionIndex = 0;
        let compatibilityMatrix = {};
        let reviewedMatrix = {}; // Track which combinations have been reviewed
        
        // Directions: [tile1Edge, tile2Edge, displayName]
        const directions = [
            ['right', 'left', 'Right → Left'],
            ['bottom', 'top', 'Bottom → Top'],
            ['left', 'right', 'Left → Right'],
            ['top', 'bottom', 'Top → Bottom']
        ];
        
        // Phaser game instance
        let game = null;
        let tile1Sprite = null;
        let tile2Sprite = null;
        let edgeHighlight1 = null;
        let edgeHighlight2 = null;
        let directionText = null;
        
        // Initialize tile keys
        function initializeTileKeys() {
            allTileKeys = [];
            for (let i = 1; i <= 16; i++) {
                allTileKeys.push(`tile-${i}`);
            }
            for (let i = 1; i <= 4; i++) {
                allTileKeys.push(`bone-${i}`);
            }
        }
        
        // Initialize compatibility matrix structure
        function initializeMatrix() {
            compatibilityMatrix = {};
            reviewedMatrix = {};
            for (const tile1 of allTileKeys) {
                if (!compatibilityMatrix[tile1]) {
                    compatibilityMatrix[tile1] = {};
                }
                if (!reviewedMatrix[tile1]) {
                    reviewedMatrix[tile1] = {};
                }
                for (const tile2 of allTileKeys) {
                    if (!compatibilityMatrix[tile1][tile2]) {
                        compatibilityMatrix[tile1][tile2] = {};
                    }
                    if (!reviewedMatrix[tile1][tile2]) {
                        reviewedMatrix[tile1][tile2] = {};
                    }
                    for (const dir of directions) {
                        const dirKey = dir[0]; // Use tile1's edge as key
                        if (!compatibilityMatrix[tile1][tile2][dirKey]) {
                            compatibilityMatrix[tile1][tile2][dirKey] = null; // null = unmarked
                        }
                        if (!reviewedMatrix[tile1][tile2][dirKey]) {
                            reviewedMatrix[tile1][tile2][dirKey] = false;
                        }
                    }
                }
            }
        }
        
        // Calculate total combinations
        function getTotalCombinations() {
            return allTileKeys.length * allTileKeys.length * directions.length;
        }
        
        // Calculate reviewed combinations
        function getReviewedCount() {
            let count = 0;
            for (const tile1 of allTileKeys) {
                for (const tile2 of allTileKeys) {
                    for (const dir of directions) {
                        const dirKey = dir[0];
                        if (reviewedMatrix[tile1] && reviewedMatrix[tile1][tile2] && 
                            reviewedMatrix[tile1][tile2][dirKey]) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }
        
        // Get current combination index
        function getCurrentCombinationIndex() {
            let index = 0;
            for (let i = 0; i < allTileKeys.length; i++) {
                for (let j = 0; j < allTileKeys.length; j++) {
                    for (let d = 0; d < directions.length; d++) {
                        if (i === currentTile1Index && j === currentTile2Index && d === currentDirectionIndex) {
                            return index;
                        }
                        index++;
                    }
                }
            }
            return 0;
        }
        
        // Update progress display
        function updateProgress() {
            const reviewed = getReviewedCount();
            const total = getTotalCombinations();
            const percentage = total > 0 ? Math.round((reviewed / total) * 100) : 0;
            
            document.getElementById('progress-text').textContent = `${reviewed} / ${total}`;
            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
        }
        
        // Update current status display
        function updateCurrentStatus() {
            const tile1 = allTileKeys[currentTile1Index];
            const tile2 = allTileKeys[currentTile2Index];
            const direction = directions[currentDirectionIndex];
            const dirKey = direction[0];
            
            document.getElementById('current-pair').textContent = `${tile1} ↔ ${tile2}`;
            document.getElementById('current-direction').textContent = direction[2];
            
            const status = compatibilityMatrix[tile1] && compatibilityMatrix[tile1][tile2] && 
                          compatibilityMatrix[tile1][tile2][dirKey];
            const statusElement = document.getElementById('current-status');
            
            if (status === true) {
                statusElement.innerHTML = '<span class="status-compatible">✓ Compatible</span>';
            } else if (status === false) {
                statusElement.innerHTML = '<span class="status-incompatible">✗ Incompatible</span>';
            } else {
                statusElement.innerHTML = '<span class="status-unmarked">Unmarked</span>';
            }
        }
        
        // Mark current combination
        function markCompatibility(compatible) {
            const tile1 = allTileKeys[currentTile1Index];
            const tile2 = allTileKeys[currentTile2Index];
            const direction = directions[currentDirectionIndex];
            const dirKey = direction[0];
            
            if (!compatibilityMatrix[tile1]) {
                compatibilityMatrix[tile1] = {};
            }
            if (!compatibilityMatrix[tile1][tile2]) {
                compatibilityMatrix[tile1][tile2] = {};
            }
            
            compatibilityMatrix[tile1][tile2][dirKey] = compatible;
            
            if (!reviewedMatrix[tile1]) {
                reviewedMatrix[tile1] = {};
            }
            if (!reviewedMatrix[tile1][tile2]) {
                reviewedMatrix[tile1][tile2] = {};
            }
            reviewedMatrix[tile1][tile2][dirKey] = true;
            
            // Also set the reverse direction for symmetric pairs
            const reverseDir = directions.find(d => d[0] === direction[1] && d[1] === direction[0]);
            if (reverseDir) {
                const reverseDirKey = reverseDir[0];
                if (!compatibilityMatrix[tile2]) {
                    compatibilityMatrix[tile2] = {};
                }
                if (!compatibilityMatrix[tile2][tile1]) {
                    compatibilityMatrix[tile2][tile1] = {};
                }
                compatibilityMatrix[tile2][tile1][reverseDirKey] = compatible;
                
                if (!reviewedMatrix[tile2]) {
                    reviewedMatrix[tile2] = {};
                }
                if (!reviewedMatrix[tile2][tile1]) {
                    reviewedMatrix[tile2][tile1] = {};
                }
                reviewedMatrix[tile2][tile1][reverseDirKey] = true;
            }
            
            // Save to localStorage
            saveToLocalStorage();
            
            // Show feedback
            const statusMsg = document.getElementById('status-message');
            statusMsg.style.display = 'block';
            statusMsg.textContent = compatible ? '✓ Marked as Compatible' : '✗ Marked as Incompatible';
            statusMsg.className = 'current-status ' + (compatible ? 'status-compatible' : 'status-incompatible');
            setTimeout(() => {
                statusMsg.style.display = 'none';
            }, 1000);
            
            updateProgress();
            updateCurrentStatus();
            updateTileDisplay();
        }
        
        // Navigate to next combination
        function nextCombination() {
            currentDirectionIndex++;
            if (currentDirectionIndex >= directions.length) {
                currentDirectionIndex = 0;
                currentTile2Index++;
                if (currentTile2Index >= allTileKeys.length) {
                    currentTile2Index = 0;
                    currentTile1Index++;
                    if (currentTile1Index >= allTileKeys.length) {
                        currentTile1Index = 0; // Loop back to start
                    }
                }
            }
            updateDisplay();
        }
        
        // Navigate to previous combination
        function previousCombination() {
            currentDirectionIndex--;
            if (currentDirectionIndex < 0) {
                currentDirectionIndex = directions.length - 1;
                currentTile2Index--;
                if (currentTile2Index < 0) {
                    currentTile2Index = allTileKeys.length - 1;
                    currentTile1Index--;
                    if (currentTile1Index < 0) {
                        currentTile1Index = allTileKeys.length - 1; // Loop to end
                    }
                }
            }
            updateDisplay();
        }
        
        // Update all displays
        function updateDisplay() {
            updateCurrentStatus();
            updateProgress();
            updateTileDisplay();
        }
        
        // Update tile display in Phaser
        function updateTileDisplay() {
            if (!game || !game.scene.scenes[0]) return;
            
            const scene = game.scene.scenes[0];
            const tile1 = allTileKeys[currentTile1Index];
            const tile2 = allTileKeys[currentTile2Index];
            const direction = directions[currentDirectionIndex];
            
            // Update tile sprites
            if (tile1Sprite) {
                tile1Sprite.setTexture(tile1);
            }
            if (tile2Sprite) {
                tile2Sprite.setTexture(tile2);
            }
            
            // Update direction text
            if (directionText) {
                directionText.setText(`${tile1} (${direction[0]}) → ${tile2} (${direction[1]})`);
            }
            
            // Update edge highlights (this also updates sprite positions)
            updateEdgeHighlights(scene, direction);
            
            // Update labels
            if (scene.updateLabels) {
                scene.updateLabels();
            }
            
            // Update status border
            const status = compatibilityMatrix[tile1] && compatibilityMatrix[tile1][tile2] && 
                          compatibilityMatrix[tile1][tile2][direction[0]];
            updateStatusBorder(scene, status);
        }
        
        // Update edge highlights
        function updateEdgeHighlights(scene, direction) {
            // Remove old highlights
            if (edgeHighlight1) edgeHighlight1.destroy();
            if (edgeHighlight2) edgeHighlight2.destroy();
            
            const highlightColor = 0x3498db;
            const highlightWidth = 4;
            
            // Calculate positions based on direction
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;
            const halfSize = TILE_DISPLAY_SIZE / 2;
            
            let tile1X, tile1Y, tile2X, tile2Y;
            
            // Position tiles based on direction
            if (direction[0] === 'right' || direction[0] === 'left') {
                // Horizontal layout
                tile1X = centerX - TILE_DISPLAY_SIZE / 2 - TILE_SPACING / 2;
                tile2X = centerX + TILE_DISPLAY_SIZE / 2 + TILE_SPACING / 2;
                tile1Y = centerY;
                tile2Y = centerY;
            } else {
                // Vertical layout
                tile1X = centerX;
                tile2X = centerX;
                tile1Y = centerY - TILE_DISPLAY_SIZE / 2 - TILE_SPACING / 2;
                tile2Y = centerY + TILE_DISPLAY_SIZE / 2 + TILE_SPACING / 2;
            }
            
            // Update sprite positions
            if (tile1Sprite) {
                tile1Sprite.setPosition(tile1X, tile1Y);
            }
            if (tile2Sprite) {
                tile2Sprite.setPosition(tile2X, tile2Y);
            }
            
            // Create graphics for highlights
            edgeHighlight1 = scene.add.graphics();
            edgeHighlight2 = scene.add.graphics();
            
            edgeHighlight1.lineStyle(highlightWidth, highlightColor, 1);
            edgeHighlight2.lineStyle(highlightWidth, highlightColor, 1);
            
            // Highlight based on direction
            switch (direction[0]) {
                case 'right':
                    // Right edge of tile1
                    edgeHighlight1.lineBetween(
                        tile1X + halfSize, tile1Y - halfSize,
                        tile1X + halfSize, tile1Y + halfSize
                    );
                    // Left edge of tile2
                    edgeHighlight2.lineBetween(
                        tile2X - halfSize, tile2Y - halfSize,
                        tile2X - halfSize, tile2Y + halfSize
                    );
                    break;
                case 'left':
                    // Left edge of tile1
                    edgeHighlight1.lineBetween(
                        tile1X - halfSize, tile1Y - halfSize,
                        tile1X - halfSize, tile1Y + halfSize
                    );
                    // Right edge of tile2
                    edgeHighlight2.lineBetween(
                        tile2X + halfSize, tile2Y - halfSize,
                        tile2X + halfSize, tile2Y + halfSize
                    );
                    break;
                case 'bottom':
                    // Bottom edge of tile1
                    edgeHighlight1.lineBetween(
                        tile1X - halfSize, tile1Y + halfSize,
                        tile1X + halfSize, tile1Y + halfSize
                    );
                    // Top edge of tile2
                    edgeHighlight2.lineBetween(
                        tile2X - halfSize, tile2Y - halfSize,
                        tile2X + halfSize, tile2Y - halfSize
                    );
                    break;
                case 'top':
                    // Top edge of tile1
                    edgeHighlight1.lineBetween(
                        tile1X - halfSize, tile1Y - halfSize,
                        tile1X + halfSize, tile1Y - halfSize
                    );
                    // Bottom edge of tile2
                    edgeHighlight2.lineBetween(
                        tile2X - halfSize, tile2Y + halfSize,
                        tile2X + halfSize, tile2Y + halfSize
                    );
                    break;
            }
        }
        
        // Update status border around tiles
        function updateStatusBorder(scene, status) {
            // This would add a colored border, but we'll keep it simple for now
            // The status is shown in the UI instead
        }
        
        // Phaser preload
        function preload() {
            // Load all tile images
            for (let i = 1; i <= 16; i++) {
                this.load.image(`tile-${i}`, `assets/world/Tiles/Tile (${i}).png`);
            }
            for (let i = 1; i <= 4; i++) {
                this.load.image(`bone-${i}`, `assets/world/Tiles/Bones (${i}).png`);
            }
            
            // Try to load existing compatibility matrix
            this.load.json('tile-compatibility-matrix', 'assets/tile-compatibility-matrix.json');
        }
        
        // Phaser create
        function create() {
            const scene = this;
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;
            
            // Create tile sprites (initial horizontal layout)
            const tile1X = centerX - TILE_DISPLAY_SIZE / 2 - TILE_SPACING / 2;
            const tile2X = centerX + TILE_DISPLAY_SIZE / 2 + TILE_SPACING / 2;
            
            tile1Sprite = scene.add.image(tile1X, centerY, allTileKeys[0]);
            tile2Sprite = scene.add.image(tile2X, centerY, allTileKeys[0]);
            
            tile1Sprite.setDisplaySize(TILE_DISPLAY_SIZE, TILE_DISPLAY_SIZE);
            tile2Sprite.setDisplaySize(TILE_DISPLAY_SIZE, TILE_DISPLAY_SIZE);
            
            // Add direction label
            directionText = scene.add.text(centerX, 30, '', {
                fontSize: '18px',
                fill: '#ffffff',
                align: 'center',
                fontStyle: 'bold'
            });
            directionText.setOrigin(0.5);
            
            // Add tile labels (will be positioned dynamically)
            const tile1Label = scene.add.text(tile1X, centerY + TILE_DISPLAY_SIZE / 2 + 25, '', {
                fontSize: '14px',
                fill: '#bdc3c7',
                align: 'center'
            });
            tile1Label.setOrigin(0.5);
            
            const tile2Label = scene.add.text(tile2X, centerY + TILE_DISPLAY_SIZE / 2 + 25, '', {
                fontSize: '14px',
                fill: '#bdc3c7',
                align: 'center'
            });
            tile2Label.setOrigin(0.5);
            
            // Store label references for updates
            scene.tile1Label = tile1Label;
            scene.tile2Label = tile2Label;
            
            // Update labels function
            function updateLabels() {
                const direction = directions[currentDirectionIndex];
                const centerX = CANVAS_WIDTH / 2;
                const centerY = CANVAS_HEIGHT / 2;
                
                let tile1X, tile1Y, tile2X, tile2Y;
                
                if (direction[0] === 'right' || direction[0] === 'left') {
                    tile1X = centerX - TILE_DISPLAY_SIZE / 2 - TILE_SPACING / 2;
                    tile2X = centerX + TILE_DISPLAY_SIZE / 2 + TILE_SPACING / 2;
                    tile1Y = centerY;
                    tile2Y = centerY;
                    
                    tile1Label.setPosition(tile1X, tile1Y + TILE_DISPLAY_SIZE / 2 + 25);
                    tile2Label.setPosition(tile2X, tile2Y + TILE_DISPLAY_SIZE / 2 + 25);
                } else {
                    tile1X = centerX;
                    tile2X = centerX;
                    tile1Y = centerY - TILE_DISPLAY_SIZE / 2 - TILE_SPACING / 2;
                    tile2Y = centerY + TILE_DISPLAY_SIZE / 2 + TILE_SPACING / 2;
                    
                    tile1Label.setPosition(tile1X, tile1Y + TILE_DISPLAY_SIZE / 2 + 25);
                    tile2Label.setPosition(tile2X, tile2Y + TILE_DISPLAY_SIZE / 2 + 25);
                }
                
                tile1Label.setText(allTileKeys[currentTile1Index]);
                tile2Label.setText(allTileKeys[currentTile2Index]);
            }
            
            // Store updateLabels in scene for access
            scene.updateLabels = updateLabels;
            
            // Initial display update
            updateDisplay();
            updateLabels();
            
            // Set up button event listeners
            setupEventListeners();
            
            // Try to load existing matrix from assets
            try {
                if (scene.cache.json.exists('tile-compatibility-matrix')) {
                    const matrix = scene.cache.json.get('tile-compatibility-matrix');
                    if (matrix && Object.keys(matrix).length > 0) {
                        loadMatrixData(matrix);
                        showStatus('Loaded existing matrix from assets/tile-compatibility-matrix.json', 'success');
                    }
                }
            } catch (e) {
                console.log('No existing matrix found in assets, starting fresh');
            }
            
            // Load from localStorage on startup (may override with saved position)
            loadFromLocalStorage();
        }
        
        // Load matrix data into compatibility matrix
        function loadMatrixData(matrix) {
            // Convert from export format to internal format
            for (const tile1 in matrix) {
                if (!compatibilityMatrix[tile1]) {
                    compatibilityMatrix[tile1] = {};
                }
                for (const tile2 in matrix[tile1]) {
                    if (!compatibilityMatrix[tile1][tile2]) {
                        compatibilityMatrix[tile1][tile2] = {};
                    }
                    for (const dirKey in matrix[tile1][tile2]) {
                        const value = matrix[tile1][tile2][dirKey];
                        // Handle both object format { compatible: true/false } and boolean
                        let compatible = null;
                        if (typeof value === 'boolean') {
                            compatible = value;
                        } else if (value && typeof value === 'object') {
                            compatible = value.compatible !== false;
                        }
                        
                        compatibilityMatrix[tile1][tile2][dirKey] = compatible;
                        
                        // Mark as reviewed if it has a value
                        if (compatible !== null) {
                            if (!reviewedMatrix[tile1]) {
                                reviewedMatrix[tile1] = {};
                            }
                            if (!reviewedMatrix[tile1][tile2]) {
                                reviewedMatrix[tile1][tile2] = {};
                            }
                            reviewedMatrix[tile1][tile2][dirKey] = true;
                        }
                    }
                }
            }
            
            saveToLocalStorage();
            updateDisplay();
        }
        
        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('btn-compatible').addEventListener('click', () => {
                markCompatibility(true);
                nextCombination();
            });
            
            document.getElementById('btn-incompatible').addEventListener('click', () => {
                markCompatibility(false);
                nextCombination();
            });
            
            document.getElementById('btn-skip').addEventListener('click', () => {
                nextCombination();
            });
            
            document.getElementById('btn-prev').addEventListener('click', () => {
                previousCombination();
            });
            
            document.getElementById('btn-next').addEventListener('click', () => {
                nextCombination();
            });
            
            document.getElementById('btn-save').addEventListener('click', () => {
                saveMatrix();
            });
            
            document.getElementById('btn-copy').addEventListener('click', () => {
                copyToClipboard();
            });
            
            document.getElementById('btn-load').addEventListener('click', () => {
                loadExistingMatrix();
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                switch (e.key.toLowerCase()) {
                    case 'y':
                        markCompatibility(true);
                        nextCombination();
                        break;
                    case 'n':
                        markCompatibility(false);
                        nextCombination();
                        break;
                    case 's':
                        nextCombination();
                        break;
                    case 'arrowright':
                        if (e.shiftKey) {
                            markCompatibility(true);
                        }
                        nextCombination();
                        break;
                    case 'arrowleft':
                        if (e.shiftKey) {
                            markCompatibility(false);
                        } else {
                            previousCombination();
                        }
                        break;
                    case ' ':
                        e.preventDefault();
                        nextCombination();
                        break;
                }
            });
        }
        
        // Save to localStorage
        function saveToLocalStorage() {
            try {
                localStorage.setItem('tileMatcherMatrix', JSON.stringify(compatibilityMatrix));
                localStorage.setItem('tileMatcherReviewed', JSON.stringify(reviewedMatrix));
                localStorage.setItem('tileMatcherPosition', JSON.stringify({
                    tile1Index: currentTile1Index,
                    tile2Index: currentTile2Index,
                    directionIndex: currentDirectionIndex
                }));
            } catch (e) {
                console.warn('Failed to save to localStorage:', e);
            }
        }
        
        // Load from localStorage
        function loadFromLocalStorage() {
            try {
                const savedMatrix = localStorage.getItem('tileMatcherMatrix');
                const savedReviewed = localStorage.getItem('tileMatcherReviewed');
                const savedPosition = localStorage.getItem('tileMatcherPosition');
                
                if (savedMatrix) {
                    const parsed = JSON.parse(savedMatrix);
                    // Merge with existing matrix
                    for (const tile1 in parsed) {
                        if (!compatibilityMatrix[tile1]) {
                            compatibilityMatrix[tile1] = {};
                        }
                        for (const tile2 in parsed[tile1]) {
                            if (!compatibilityMatrix[tile1][tile2]) {
                                compatibilityMatrix[tile1][tile2] = {};
                            }
                            Object.assign(compatibilityMatrix[tile1][tile2], parsed[tile1][tile2]);
                        }
                    }
                }
                
                if (savedReviewed) {
                    const parsed = JSON.parse(savedReviewed);
                    Object.assign(reviewedMatrix, parsed);
                }
                
                if (savedPosition) {
                    const pos = JSON.parse(savedPosition);
                    currentTile1Index = pos.tile1Index || 0;
                    currentTile2Index = pos.tile2Index || 0;
                    currentDirectionIndex = pos.directionIndex || 0;
                }
                
                updateDisplay();
                showStatus('Loaded previous progress from localStorage', 'success');
            } catch (e) {
                console.warn('Failed to load from localStorage:', e);
            }
        }
        
        // Load existing matrix from file
        function loadExistingMatrix() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const matrix = JSON.parse(event.target.result);
                        loadMatrixData(matrix);
                        showStatus('Matrix loaded successfully!', 'success');
                    } catch (error) {
                        showStatus(`Error loading matrix: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // Convert matrix to export format (matching existing format)
        function getExportMatrix() {
            const exportMatrix = {};
            
            for (const tile1 of allTileKeys) {
                if (!exportMatrix[tile1]) {
                    exportMatrix[tile1] = {};
                }
                for (const tile2 of allTileKeys) {
                    if (!exportMatrix[tile1][tile2]) {
                        exportMatrix[tile1][tile2] = {};
                    }
                    for (const dir of directions) {
                        const dirKey = dir[0];
                        const value = compatibilityMatrix[tile1] && 
                                     compatibilityMatrix[tile1][tile2] && 
                                     compatibilityMatrix[tile1][tile2][dirKey];
                        
                        if (value === true) {
                            exportMatrix[tile1][tile2][dirKey] = { compatible: true };
                        } else if (value === false) {
                            exportMatrix[tile1][tile2][dirKey] = { compatible: false };
                        } else {
                            // Unmarked - use default compatible
                            exportMatrix[tile1][tile2][dirKey] = { compatible: true };
                        }
                    }
                }
            }
            
            return exportMatrix;
        }
        
        // Save matrix to file
        function saveMatrix() {
            const matrix = getExportMatrix();
            const json = JSON.stringify(matrix, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tile-compatibility-matrix.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('Matrix saved! Save it to assets/tile-compatibility-matrix.json', 'success');
        }
        
        // Copy to clipboard
        function copyToClipboard() {
            const matrix = getExportMatrix();
            const json = JSON.stringify(matrix, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                showStatus('Copied to clipboard! Paste into assets/tile-compatibility-matrix.json', 'success');
            }).catch(err => {
                showStatus(`Failed to copy: ${err.message}`, 'error');
            });
        }
        
        // Show status message
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 5000);
        }
        
        // Initialize
        initializeTileKeys();
        initializeMatrix();
        
        // Create Phaser game
        const config = {
            type: Phaser.AUTO,
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            parent: 'game-container',
            backgroundColor: '#34495e',
            scene: {
                preload: preload,
                create: create
            }
        };
        
        game = new Phaser.Game(config);
        
        // Initial progress update
        updateProgress();
    </script>
</body>
</html>
